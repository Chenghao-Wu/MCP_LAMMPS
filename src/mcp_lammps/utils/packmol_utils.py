"""
Packmol Utilities - Integration with Packmol for molecular packing.

This module provides functionality to use Packmol (external binary) for creating
well-packed molecular systems without overlaps. Packmol is a molecular packing
optimization tool that generates initial configurations for molecular dynamics.

Requirements:
    - Packmol binary must be installed on the system
    - Installation: apt install packmol (Linux) or brew install packmol (macOS)
    - Website: http://m3g.iqm.unicamp.br/packmol/
"""

import logging
import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
import numpy as np

logger = logging.getLogger(__name__)


class PackmolError(Exception):
    """Exception raised when Packmol operations fail."""
    pass


class PackmolUtils:
    """
    Utility class for Packmol molecular packing operations.
    
    This class handles:
    - Checking Packmol binary availability
    - Generating Packmol input files
    - Writing molecule PDB files
    - Running Packmol subprocess
    - Parsing packed structure output
    """
    
    def __init__(self):
        """Initialize Packmol utilities and check binary availability."""
        self.packmol_bin = self._find_packmol_binary()
        if not self.packmol_bin:
            raise PackmolError(
                "Packmol binary not found. Please install Packmol:\n"
                "  - Ubuntu/Debian: sudo apt install packmol\n"
                "  - macOS: brew install packmol\n"
                "  - From source: http://m3g.iqm.unicamp.br/packmol/"
            )
        logger.info(f"Found Packmol binary at: {self.packmol_bin}")
    
    def _find_packmol_binary(self) -> Optional[str]:
        """
        Find Packmol binary in system PATH.
        
        Returns:
            Path to Packmol binary or None if not found
        """
        return shutil.which('packmol')
    
    def check_packmol_available(self) -> bool:
        """
        Check if Packmol is available on the system.
        
        Returns:
            True if Packmol binary exists, False otherwise
        """
        return self.packmol_bin is not None
    
    def write_molecule_pdb(
        self,
        molecule: Any,
        output_path: Path,
        molecule_name: str = "MOL"
    ) -> Path:
        """
        Write OpenFF Molecule to PDB file for Packmol input.
        
        Args:
            molecule: OpenFF Molecule object with conformer
            output_path: Path to write PDB file
            molecule_name: Residue name for PDB
            
        Returns:
            Path to written PDB file
        """
        try:
            # Use OpenFF's built-in PDB export, then modify residue names
            molecule.to_file(str(output_path), file_format='pdb')
            
            logger.debug(f"Wrote molecule PDB to {output_path}")
            return output_path
            
        except Exception as e:
            logger.error(f"Failed to write molecule PDB: {e}")
            raise PackmolError(f"Failed to write molecule PDB: {e}")
    
    def generate_packmol_input(
        self,
        molecule_files: List[Tuple[Path, int]],
        output_pdb: Path,
        box_size: float,
        tolerance: float = 2.0,
        seed: int = -1
    ) -> str:
        """
        Generate Packmol input file content.
        
        Args:
            molecule_files: List of (pdb_file_path, count) tuples
            output_pdb: Path for output packed structure
            box_size: Box size in Angstroms
            tolerance: Minimum distance between atoms (Angstroms)
            seed: Random seed (-1 for random)
            
        Returns:
            Packmol input file content as string
        """
        lines = [
            "# Packmol input generated by mcp_lammps",
            f"tolerance {tolerance}",
            "filetype pdb",
            f"output {output_pdb}",
        ]
        
        if seed != -1:
            lines.append(f"seed {seed}")
        
        # Add structure blocks for each molecule type
        for pdb_file, count in molecule_files:
            # Define region as a cube slightly smaller than box to avoid boundary issues
            margin = 1.0  # Angstrom margin from box edges
            lines.extend([
                "",
                f"structure {pdb_file}",
                f"  number {count}",
                f"  inside cube {margin:.3f} {margin:.3f} {margin:.3f} {box_size - 2*margin:.3f}",
                "end structure"
            ])
        
        return "\n".join(lines) + "\n"
    
    def run_packmol(
        self,
        input_content: str,
        work_dir: Path
    ) -> Tuple[str, str]:
        """
        Run Packmol with given input content.
        
        Args:
            input_content: Packmol input file content
            work_dir: Working directory for execution
            
        Returns:
            Tuple of (stdout, stderr) from Packmol execution
            
        Raises:
            PackmolError: If Packmol execution fails
        """
        try:
            # Write input file
            input_file = work_dir / "packmol.inp"
            with open(input_file, 'w') as f:
                f.write(input_content)
            
            logger.info(f"Running Packmol in {work_dir}")
            logger.debug(f"Packmol input:\n{input_content}")
            
            # Run Packmol
            result = subprocess.run(
                [self.packmol_bin],
                stdin=open(input_file, 'r'),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=work_dir,
                text=True,
                timeout=300  # 5 minute timeout
            )
            
            stdout = result.stdout
            stderr = result.stderr
            
            # Log output
            if stdout:
                logger.debug(f"Packmol stdout:\n{stdout}")
            if stderr:
                logger.debug(f"Packmol stderr:\n{stderr}")
            
            # Check for success
            if result.returncode != 0:
                raise PackmolError(
                    f"Packmol failed with return code {result.returncode}\n"
                    f"stderr: {stderr}\n"
                    f"stdout: {stdout}"
                )
            
            # Check if output indicates success
            if "Success!" not in stdout and "ENDED WELL" not in stdout:
                # Some versions of Packmol don't print success message
                # Check if output file was created instead
                output_file = work_dir / "output.pdb"
                if not output_file.exists():
                    raise PackmolError(
                        f"Packmol did not create output file\n"
                        f"stdout: {stdout}\n"
                        f"stderr: {stderr}"
                    )
            
            logger.info("Packmol completed successfully")
            return stdout, stderr
            
        except subprocess.TimeoutExpired:
            raise PackmolError("Packmol execution timed out after 5 minutes")
        except Exception as e:
            if isinstance(e, PackmolError):
                raise
            logger.error(f"Failed to run Packmol: {e}")
            raise PackmolError(f"Failed to run Packmol: {e}")
    
    def parse_packed_structure(
        self,
        pdb_file: Path,
        expected_atoms: int
    ) -> np.ndarray:
        """
        Parse Packmol output PDB file and extract atomic coordinates.
        
        Args:
            pdb_file: Path to Packmol output PDB file
            expected_atoms: Expected number of atoms for validation
            
        Returns:
            NumPy array of shape (N_atoms, 3) with coordinates in Angstroms
            
        Raises:
            PackmolError: If parsing fails or atom count mismatch
        """
        try:
            if not pdb_file.exists():
                raise PackmolError(f"Packmol output file not found: {pdb_file}")
            
            positions = []
            
            with open(pdb_file, 'r') as f:
                for line in f:
                    # Parse ATOM and HETATM records
                    if line.startswith(('ATOM', 'HETATM')):
                        # PDB format: columns 31-38 (x), 39-46 (y), 47-54 (z)
                        try:
                            x = float(line[30:38].strip())
                            y = float(line[38:46].strip())
                            z = float(line[46:54].strip())
                            positions.append([x, y, z])
                        except (ValueError, IndexError) as e:
                            logger.warning(f"Failed to parse PDB line: {line.strip()}, error: {e}")
                            continue
            
            if not positions:
                raise PackmolError("No atomic coordinates found in Packmol output")
            
            positions_array = np.array(positions)
            
            # Validate atom count
            if len(positions_array) != expected_atoms:
                raise PackmolError(
                    f"Atom count mismatch: expected {expected_atoms}, "
                    f"got {len(positions_array)} from Packmol output"
                )
            
            logger.info(f"Parsed {len(positions_array)} atomic positions from Packmol output")
            return positions_array
            
        except Exception as e:
            if isinstance(e, PackmolError):
                raise
            logger.error(f"Failed to parse Packmol output: {e}")
            raise PackmolError(f"Failed to parse Packmol output: {e}")
    
    def pack_molecules(
        self,
        molecules: List[Any],
        counts: List[int],
        box_size: float,
        tolerance: float = 2.0,
        seed: int = -1
    ) -> np.ndarray:
        """
        Pack molecules into a box using Packmol.
        
        This is the main high-level method that orchestrates the packing process.
        
        Args:
            molecules: List of OpenFF Molecule objects (unique types)
            counts: Number of each molecule type
            box_size: Box size in Angstroms
            tolerance: Minimum distance between atoms (Angstroms)
            seed: Random seed for reproducibility (-1 for random)
            
        Returns:
            NumPy array of shape (N_atoms, 3) with packed coordinates in Angstroms
            
        Raises:
            PackmolError: If packing fails
        """
        # Create temporary directory for Packmol files
        with tempfile.TemporaryDirectory(prefix="packmol_") as tmp_dir:
            work_dir = Path(tmp_dir)
            logger.info(f"Created temporary directory: {work_dir}")
            
            # Write individual molecule PDB files
            molecule_files = []
            total_atoms = 0
            
            for i, (molecule, count) in enumerate(zip(molecules, counts)):
                mol_name = molecule.name or f"MOL{i}"
                pdb_file = work_dir / f"molecule_{i}.pdb"
                self.write_molecule_pdb(molecule, pdb_file, mol_name)
                molecule_files.append((pdb_file, count))
                total_atoms += molecule.n_atoms * count
            
            # Generate Packmol input
            output_pdb = work_dir / "output.pdb"
            input_content = self.generate_packmol_input(
                molecule_files,
                output_pdb,
                box_size,
                tolerance,
                seed
            )
            
            # Run Packmol
            self.run_packmol(input_content, work_dir)
            
            # Parse output
            positions = self.parse_packed_structure(output_pdb, total_atoms)
            
            logger.info(f"Successfully packed {len(molecules)} molecule types "
                       f"({sum(counts)} total molecules, {total_atoms} atoms)")
            
            return positions


# Create a global instance for easy access
packmol_utils = PackmolUtils()

